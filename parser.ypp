%{
// C user declarations
#include <iostream>
#include <string>
#include "hw3_output.hpp"
#include "stypes.hpp"
#include "bp.hpp"

#define GET_SYM(x) symbolTable.getVarSymbol(STYPE2STD(string, x))
#define GET_SYMTYPE(x) symbolTable.getVarSymbol(STYPE2STD(string, x))->getType()

#define GET_FUNC(x) symbolTable.getFuncSymbol(STYPE2STD(string, x))
#define GET_FUNCTYPE(x) symbolTable.getFuncSymbol(STYPE2STD(string, x))->getType()


namespace yy {
using namespace output;
using namespace std;
}
using namespace output;
using namespace std;

SymbolTable symbolTable;

%}

%code requires {
   #include "stypes.hpp"
}

/* Declarations */
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMENT
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%nonassoc COMMA
%right ELSE
%right ASSIGN
%left OR
%left AND
%left EQOP NEOP
%left GEOP GTOP LEOP LTOP
%left ADDOP SUBOP
%left MULOP DIVOP
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%nonassoc SECOND_PRIOR;
%nonassoc FIRST_PRIOR;

%%
/* Rules */
Program:        Funcs                               {}
                ;
Funcs:          /* epsilon */ %empty %prec SECOND_PRIOR    {}
                | FuncDecl Funcs %prec FIRST_PRIOR  {};
FuncDecl:       RetType ID LPAREN Formals           {
                                                        auto formals = STYPE2STD(vector<shared_ptr<IdC> >, $4);
                                                        vector<string> argTypes;
                                                        for (auto i = 0; i < formals.size(); i++) {
                                                            argTypes.push_back(formals[i]->getType());
                                                        }

                                                        shared_ptr<FuncIdC> funcId(NEW(FuncIdC, (STYPE2STD(string, $2), DC(RetTypeNameC, $1)->getTypeName(), argTypes)));
                                                        symbolTable.addSymbol(STYPE2STD(string, $2), funcId);

                                                        symbolTable.addScope(formals.size());
                                                        for (auto i = 0; i < formals.size(); i++) {
                                                            symbolTable.addFormal(formals[i]);
                                                        }
                                                        symbolTable.retType = DC(RetTypeNameC, $1);
                                                    }
                    RPAREN LBRACE Statements RBRACE {
                                                        symbolTable.removeScope();
                                                        string retTypeLlvm = typeNameToLlvmType(symbolTable.retType);
                                                        string defaultRetVal = retTypeLlvm + (retTypeLlvm == "void" ? "" : " 0");
                                                        symbolTable.retType = nullptr;
                                                        auto &codeBuffer = CodeBuffer::getInstance();
                                                        codeBuffer.emit("ret" + defaultRetVal);
                                                        // To balance rainbow brackets {
                                                        codeBuffer.emit("}");
                                                    }
;
RetType:        Type                                { $$ = $1; }
                | VOID                              { $$ = NEW(RetTypeNameC, ("VOID")); }
                ;
Formals:        /* Epsilon */%empty                 { $$ = NEWSTD(vector<shared_ptr<IdC> >); }
                | FormalsList                       { $$ = $1; }
;
FormalsList:    FormalDecl                          {
                                                        auto vec = vector<shared_ptr<IdC> >();
                                                        vec.push_back(DC(IdC, $1));
                                                        $$ = NEWSTD_V(vector<shared_ptr<IdC> >, (vec));
                                                    }
                | FormalDecl COMMA FormalsList      {
                                                        STYPE2STD(vector<shared_ptr<IdC> >, $3).push_back(DC(IdC, $1));
                                                        $$ = $3;
                                                    }
                ;
FormalDecl:     TypeDecl                            { $$ = $1; }
                ;
Statements:     Statement                           {}
                | Statements Statement              {}
                ;
OpenScope:      /* epsilon */ %empty                {symbolTable.addScope();};
CloseScope:      /* epsilon */ %empty               {symbolTable.removeScope();};
Statement:      LBRACE OpenScope Statements RBRACE CloseScope
                | TypeDecl SC                       {
                                                        auto symbol = DC(IdC, $1);
                                                        symbolTable.addSymbol(symbol->getName(), symbol);
                                                    }
                | TypeDecl ASSIGN Exp SC            {
                                                        auto symbol = DC(IdC, $1);
                                                        symbolTable.addSymbol(symbol->getName(), symbol);
                                                        if (not areStrTypesCompatible(symbol->getType(), DC(ExpC, $3)->getType())) {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | AUTO ID ASSIGN Exp SC             {symbolTable.addSymbol(STYPE2STD(string, $2), NEW(IdC,(STYPE2STD(string, $2), DC(ExpC, $4)->getType())));}
                | ID ASSIGN Exp SC                  {
                                                        if (not areStrTypesCompatible(GET_SYMTYPE($1), DC(ExpC,$3)->getType())) {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | Call SC                           {}
                | RETURN SC                         {
                                                        if (symbolTable.retType == nullptr) {
                                                            throw "This should be impossible. Syntax error wise";
                                                        } else if (symbolTable.retType->getTypeName() != "VOID") {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | RETURN Exp SC                     {
                                                        if (symbolTable.retType == nullptr) {
                                                            throw "This should be impossible. Syntax error wise";
                                                        } else if (not areStrTypesCompatible(symbolTable.retType->getTypeName(), DC(ExpC, $2)->getType())) {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | IF LPAREN BoolExp RPAREN OpenScope Statement CloseScope %prec IF {}
                | IF LPAREN BoolExp RPAREN OpenScope Statement CloseScope ELSE OpenScope Statement CloseScope
                | WHILE LPAREN BoolExp RPAREN {symbolTable.nestedLoopDepth++;} OpenScope Statement CloseScope {symbolTable.nestedLoopDepth--;}
                | BREAK SC                          {
                                                        if (symbolTable.nestedLoopDepth == 0) {
                                                            errorUnexpectedBreak(yylineno);
                                                        }
                                                    }
                | CONTINUE SC                       {
                                                        if (symbolTable.nestedLoopDepth == 0) {
                                                            errorUnexpectedContinue(yylineno);
                                                        }
                                                    }
                ;
TypeDecl:       Type ID                             { $$ = NEW(IdC, (STYPE2STD(string, $2), DC(VarTypeNameC, $1)->getTypeName())); }
                ;
Call:           ID LPAREN ExpList RPAREN            { $$ = ExpC::getCallResult(GET_FUNC($1), $3); }
                | ID LPAREN RPAREN                  { $$ = ExpC::getCallResult(GET_FUNC($1), NEWSTD(vector<shared_ptr<ExpC> >)); }
                ;
ExpList:        Exp                                 {
                                                        $$ = NEWSTD(vector<shared_ptr<ExpC> >);
                                                        STYPE2STD(vector<shared_ptr<ExpC> >, $$).push_back(DC(ExpC, $1));
                                                    }
                | Exp COMMA ExpList                 {
                                                        STYPE2STD(vector<shared_ptr<ExpC> >, $3).push_back(DC(ExpC, $1));
                                                        $$ = $3;
                                                    }
                ;
Type:           INT                                 { $$ = NEW(VarTypeNameC, ("INT")); }
                | BYTE                              { $$ = NEW(VarTypeNameC, ("BYTE")); }
                | BOOL                              { $$ = NEW(VarTypeNameC, ("BOOL")); }
                ;
BoolExp: Exp                                        { verifyBoolType($1); $$ = $1; }
Exp:            LPAREN Exp RPAREN                   { $$ = $2; }
                | Exp ADDOP Exp                     { $$ = ExpC::getBinOpResult($1, $3, $2); }
                | Exp SUBOP Exp                     { $$ = ExpC::getBinOpResult($1, $3, $2); }
                | Exp MULOP Exp                     { $$ = ExpC::getBinOpResult($1, $3, $2); }
                | Exp DIVOP Exp                     { $$ = ExpC::getBinOpResult($1, $3, $2); }
                | ID                                { $$ = ExpC::loadIdValue(GET_SYM($1)); } // TODO: Implement
                | Call                              { $$ = $1 != nullptr ? $1: throw "Can't derive Call from Exp for void functions"; } // TODO: Implement
                | NUM                               { $$ = NEW(ExpC,("INT", STYPE2STD(string, $1))); }
                | NUM B                             { $$ = NEW(ExpC,("BYTE", STYPE2STD(string, $1))); }
                | STRING                            { $$ = ExpC::loadStringLiteralAddr(STYPE2STD(string, $1)); }
                | TRUE                              { $$ = NEW(ExpC,("BOOL", "1")); }
                | FALSE                             { $$ = NEW(ExpC,("BOOL", "0")); }
                | NOT Exp                           { $$ = ExpC::evalBool($2, nullptr, NOT); }
                | Exp AND Exp                       { $$ = ExpC::evalBool($1, $3, AND); }
                | Exp OR Exp                        { $$ = ExpC::evalBool($1, $3, OR); }
                | Exp GEOP Exp                      { $$ = ExpC::getCmpResult($1, $3, GEOP); }
                | Exp GTOP Exp                      { $$ = ExpC::getCmpResult($1, $3, GTOP); }
                | Exp LEOP Exp                      { $$ = ExpC::getCmpResult($1, $3, LEOP); }
                | Exp LTOP Exp                      { $$ = ExpC::getCmpResult($1, $3, LTOP); }
                | Exp EQOP Exp                      { $$ = ExpC::getCmpResult($1, $3, EQOP); }
                | Exp NEOP Exp                      { $$ = ExpC::getCmpResult($1, $3, NEOP); }
                | LPAREN Type RPAREN Exp            { $$ = NEW(ExpC, ($2, $4)); }
                ;
%%


/* User routines */
int main() {
    yyparse();
    verifyMainExists(symbolTable);
    return 0;
}
